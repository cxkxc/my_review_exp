[TOC]

## 操作系统常见面试问题





#### 进程与线程的区别和联系



#### 一个进程可以创建多少线程，和什么有关

> 1. 进程：
>
> 默认4096个进程，可以更改
>
> 2. 线程（内存大小，线程栈大小，操作系统位数）
>
> 创建一个线程会占用多少内存，这取决于分配给线程的调用栈大小，可以用ulimit -s命令来查看大小（一般常见的有10M或者是8M）。我们还知道，一个进程的虚拟内存是4G，在Linux32位平台下，内核分走了1G，留给用户用的只有3G，于是我们可以想到，创建一个线程占有了10M内存，总共有3G内存可以使用。于是可想而知，最多可以创建差不多300个左右的线程。



#### 一个程序从开始运行到结束的完整过程（四个过程）

> 1. 预处理
>
> 主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。
>
> 2. 编译
>
> 编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。
>
> 3. 汇编
>
> 汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。
>
> 4. 链接
>
> 链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。



#### 文件读写使用的系统调用

> open 打开或创建文件
> creat 创建文件
> close 关闭文件
> read 读文件
> write 写文件
> lseek 设置文件读写位置
> unlink 删除链接
> remove 删除文件



#### 怎么回收线程



#### 守护进程、僵尸进程和孤儿进程

> 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。
>
> **孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。****孤儿进程并不会有什么危害。**
>
> **僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**(把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，)



#### [处理僵尸进程的两种经典方法](https://www.cnblogs.com/scut-fm/archive/2013/10/29/3393686.html)

> **方法一：父进程回收法**
>
> 　　wait函数将使其调用者阻塞，直到其某个子进程终止。故父进程可调用wait函数回收其僵尸子进程。除此之外，waitpid函数提供更为详尽的功能( 增加了非阻塞功能以及指定等待功能 )
>
> **方法二：init进程回收法**
>
> 1. 如果父进程先于子进程结束，那么子进程的父进程自动改为 init 进程。
> 2. 如果 init 的子进程结束，则 init 进程会自动回收其子进程的资源而不是让它变成僵尸进程。

#### 进程终止的几种方式



#### linux中异常和中断的区别

> **1. 中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。**
>
> ![img](https://img-blog.csdn.net/20130809153216703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> **2. 异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常。**
>
> ![img](https://img-blog.csdn.net/20130809153511562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> **3. 异同**
>
> ​      ①**相同点：**
>
> ​    	**1> 最后都是由CPU发送给内核，由内核去处理**
>
> ​	    **2> 处理程序的流程设计上是相似的**
>
> ​      ②**不同点：**
>
> ​	    **1> 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的**
>
> ​	    **2> 内核需要根据是异常还是中断调用不同的处理程序**  
>
> ​	    **3> 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以，它是时钟同步的**
>
> ​    	**4> 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中**
>
> 



#### 一般情况下在Linux/windows平台下栈空间的大小

> linux: 8 M; ($ ulimit -a | grep stack)
>
> windows: 1M; 



#### 五种IO模型

> 1)阻塞I/O（blocking I/O）
> 2)非阻塞I/O （nonblocking I/O）
> 3) I/O复用(select 和poll) （I/O multiplexing）
> 4)信号驱动I/O （signal driven I/O (SIGIO)）
> 5)异步I/O （asynchronous I/O (the POSIX aio_functions)）
>
> 前四种都是同步，只有最后一种才是异步IO。

#### 守护进程

#### 程序从堆中动态分配内存时，虚拟内存上怎么操作的

#### 交换空间与虚拟内存的关系

> 第一层理解
>
> ​        1.每个进程都有自己独立的4G(32位系统下)内存空间，各个进程的内存空间具有类似的结构
>
> ​        2.一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录
>
> ​        3.每个进程已经分配的内存空间，都与对应的磁盘空间映射
>
> 第二层理解
>
> ​        1.每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址
>
> ​        2.所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。
>
> ​        3.进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录
>
> ​        4.页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
>
> ​        5.当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常
>
> ​        6.缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘
>
> **内存与swap之间是按照内存页为单位来交换数据的，一般Linux中页的大小设置为4kb。而内存与磁盘则是按照块来交换数据的。**



#### 内存泄漏和内存溢出



#### 常见内存分配方式和错误

> 1. 内存分配方式有三种：
>
> （1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
>
> （2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
>
> （3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。
>
> 2. 常见的内存错误及其对策
>
> - 内存分配未成功，却使用了它。
>
> 常用解决办法是，在使用内存之前检查指针是否为NULL。
>
> - 内存分配虽然成功，但是尚未初始化就引用它。
>
> 犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。
>
> - 内存分配成功并且已经初始化，但操作越过了内存的边界。
>
> 例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。
>
> - 忘记了释放内存，造成内存泄露。
>
> 动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。
>
> - 释放了内存却继续使用它。
>
> 有三种情况：
>
> （1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。
>
> （2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
>
> （3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。
>
> **【规则1】**用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
>
> **【规则2】**不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
>
> **【规则3】**避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
>
> **【规则4】**动态内存的申请与释放必须配对，防止内存泄漏。
>
> **【规则5】**用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。



#### [可重入函数和可重入内核](https://blog.csdn.net/chj1234chj/article/details/78162443?locationNum=7&fps=1)



#### 操作系统动态内存分配的几种策略



#### 内部碎片和外部碎片



#### 内核态和用户态的区别

> 当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。
>
> 用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。
>
> 当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。



#### 系统调用进入内核态的过程

> **用户态切换到内核态的3种方式**
>
> （1）系统调用
>
> 这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如fork（）就是执行了一个创建新进程的系统调用。系统调用的机制是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。
>
> （2）异常
>
> 当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。
>
> （3）外围设备的中断
>
> 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。
>
> 这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤有事一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致



#### 常见的进程调度算法以及linux的进程调度

> 进程调度：在操作系统中调度是指一种资源分配。
>
> 调度算法是指: 根据系统的资源分配策略所规定的资源分配算法。
>
> 操作系统管理了系统的有限资源，当有多个进程(或多个进程发出的请求)要使用这些资源时，因为资源的有限性，必须按照一定的原则选择进程(请求)来占用资源。这就是调度。目的是控制资源使用者的数量,选取资源使用者许可占用资源或占用资源。
>
> 那么我们看一下常见的进程调度算法：
>
> 1. 先来先去服务：
> 2. 短作业(进程)优先调度算法SJ(P)F：
> 3. 轮转法：
> 4. 多级反馈队列算法：



#### 中断、陷阱、故障和终止



#### 进程通信方法

> 同步进程通信：管道、FIFO（命名管道）、消息队列、共享内存、信号量（用于进程同步）、socket套接字
>
> 异步进程通信：信号



#### 线程互斥和同步的方法

> 互斥：互斥量、读写锁、自旋锁
>
> 同步：轮询结合互斥量、条件变量、信号量、屏障



#### 内存对齐的规则和作用

> 1、  平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
>
> 2、  性能原因：经过内存对齐后，CPU的内存访问速度大大提升。



#### 页面置换算法

> 最佳置换算法（OPT）
>
> 先进先出（FIFO）
>
> 最近最久未使用（LRU）
>
> Clock置换算法（也称之为最近未使用算法NRU）
>
> ```
> 由访问位A和修改位M可以组合成下面四种类型的页面：
> 1类(A=0, M=0): 表示该页最近既未被访问， 又未被修改， 是最佳淘汰页。
> 2类(A=0, M=1)： 表示该页最近未被访问， 但已被修改， 并不是很好的淘汰页。
> 3类(A=1, M=0)： 最近已被访问， 但未被修改， 该页有可能再被访问。
> 4类(A=1, M=1): 最近已被访问且被修改， 该页可能再被访问。
> ```
>
> 



#### 实现一个LRU页置换算法（或者FIFO置换算法）



#### 死锁的必要条件（怎么检测死锁，解决死锁问题）,银行家算法（死锁避免）

> 1. 死锁的必要条件
>
> 1）互斥条件
>
> 2）不剥夺条件
>
> 3）请求和保持条件
>
> 4）循环等待
>
> 2. 预防死锁
>
> 通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。
>
> 1）破坏互斥：有些资源必须互斥访问；
>
> 2）破坏不可剥夺：请求资源被拒绝，必须放弃它最初占用的资源；
>
> 3）破坏请求和保持：程序开始运行前，分配所有资源；
>
> 4）破坏循环等待：给资源编号，只能按顺序递增申请资源。
>
> 3. 避免死锁
>
> 银行家算法：至少存在一个安全序列
>
> 4. 检查死锁
>
> 1）第一步：先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞（“不阻塞”即：系统有足够的空闲资源分配给它）的
>
> 2）第二步：把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来
>
> 3）第三步：看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。
>
> 4）第四步：最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”。
>
> 如果一个图可完全简化，则不会产生死锁；如果一个图不可完全简化（即：图中还有“边”存在），则会产生死锁。这就是“死锁定理”。 
>
> ![](C:\Users\kongx\Desktop\面试常考\操作系统常见面试问题.assets\死锁检测.PNG)
>
> 5. 解除死锁：
>
> 1）抢占资源
>
> 2）终止或者撤销进程



#### 哲学家就餐，读者写者，生产者消费者（怎么加锁解锁，伪代码）



#### 海量数据的bitmap使用原理



#### 布隆过滤器原理与优点



#### 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题
