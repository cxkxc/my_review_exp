## 数据库常见面试问题

### 数据库

#### 关系型和非关系型数据库的区别（各自优点）

> 1.关系型数据库通过外键关联来建立表与表之间的关系，
> 2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定
>
> ```
> 比如 有一个学生的数据：姓名：张三，性别：男，学号：12345，班级：二年级一班
> 还有一个班级的数据：班级：二年级一班，班主任：李四
> 关系型数据库中，我们创建学生表和班级表来存这两条数据，并且学生表中的班级存储的是班级表中的主键。
> 非关系型数据库中，我们创建两个对象，一个是学生对象，一个是班级对象，
> ```

#### 常用SQL语句（DDL,DML,DCL,TCL）

```mysql
一、数据库操作：　
	1、查看数据库：

　　　　>SHOW DATABASES;

　　2、创建数据库：

　　　　>CREATE DATABASE db_name;　　//db_name为数据库名

　　3、使用数据库：

　　　　>USE db_name;

　　4、删除数据库：

　　　　>DROP DATABASE db_name;

二、创建表：

　　1、创建表：

　　　　>CREATE TABLE table_name(

　　　　>id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT,　//id值，无符号、非空、递增——唯一性，可做主键。

　　　　>name VARCHAR(60) NOT NULL

　　　　>score TINYINT UNSIGNED NOT NULL DEFAULT 0,　　　　//设置默认列值

　　　　>PRIMARY KEY(id)

　　　　>)ENGINE=InnoDB　　　　//设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索

　　　　>DEFAULT charset=utf8;　　//设置默认的编码，防止数据库中文乱码

　　　　如果有条件的创建数据表还可以使用   >CREATE TABLE IF NOT EXISTS tb_name(........

　　2、复制表：

　　　　>CREATE TABLE tb_name2 SELECT * FROM tb_name;

　　　　或者部分复制：

　　　　>CREATE TABLE tb_name2 SELECT id,name FROM tb_name;

　　3、创建临时表：

　　　　>CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样);

　　4、查看数据库中可用的表：

　　　　>SHOW TABLES;

　　5、查看表的结构：

　　　　>DESCRIBE tb_name;

　　　　也可以使用：

　　　　>SHOW COLUMNS in tb_name; 　　　　//from也可以

　　6、删除表：

　　　　>DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2.......];

　　　　实例：

　　　　>DROP TABLE IF EXISTS tb_name;

　　7、表重命名：

　　　　>RENAME TABLE name_old TO name_new;

　　　　还可以使用：

　　　　>ALTER TABLE name_old RENAME name_new;

三、修改表：

　　1、更改表结构：

　　　　>ALTER TABLE tb_name ADD[CHANGE,RENAME,DROP] ...要更改的内容...

　　　　实例：

　　　　>ALTER TABLE tb_name ADD COLUMN address varchar(80) NOT NULL;

　　　　>ALTER TABLE tb_name DROP address;

　　　　>ALTER TABLE tb_name CHANGE score score SMALLINT(4) NOT NULL;

四、插入数据：

　　1、插入数据：

　　　　>INSERT INTO tb_name(id,name,score)VALUES(NULL,'张三',140),(NULL,'张四',178),(NULL,'张五',134);

　　　　这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。

　　2、插入检索出来的数据：

　　　　>INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2;

五、更新数据：

　　1、指定更新数据：

　　　　>UPDATE tb_name SET score=189 WHERE id=2;

　　　　>UPDATE tablename SET columnName=NewValue [ WHERE condition ]

六、删除数据：

　　1、删除数据：

　　　　>DELETE FROM tb_name WHERE id=3;
```



- 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写

  

#### 数据库的索引类型

> 1. 索引定义
>    数据库[索引](http://baike.baidu.com/view/262241.htm)好比是一本书前面的目录，能加快数据库的查询速度。[索引](http://baike.baidu.com/view/262241.htm)是对数据库表中一个或多个列（例如，employe 表的姓氏 (lname) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。
> 2. 建立索引的优缺点：
>    优点：
>    1. 大大加快数据的检索速度;       
>    2. 创建唯一性索引，保证数据库表中每一行数据的唯一性;     
>    3. 加速表和表之间的连接;       
>    4. 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。
>
> 缺点：　　
>
> 1. 索引需要占用数据表以外的物理存储空间　　
> 2. 创建索引和维护索引要花费一定的时间　　
> 3. 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
> 4. 索引类型：  
>
> 根据数据库的功能，可以在数据库设计器中创建索引：唯一索引、主键索引和聚集索引。 尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。  
>
> 唯一索引：   UNIQUE     例如：create unique index stusno on student（sno）；表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。
>
> 主键索引：   primary key数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。   在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 
>
> 聚集索引（也叫聚簇索引）：cluster  在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。   如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。
>
> 4. 索引的实现方式
>    1. B+树
>       我们经常听到B+树就是这个概念，用这个树的目的和红黑树差不多，也是为了尽量保持树的平衡，当然红黑树是二叉树，但B+树就不是二叉树了，节点下面可以有多个子节点，数据库开发商会设置子节点数的一个最大值，这个值不会太小，所以B+树一般来说比较矮胖，而红黑树就比较瘦高了。关于B+树的插入，删除，会涉及到一些算法以保持树的平衡，这里就不详述了。ORACLE的默认索引就是这种结构的。如果经常需要同时对两个字段进行AND查询,那么使用两个单独索引不如建立一个复合索引，因为两个单独索引通常数据库只能使用其中一个，而使用复合索引因为索引本身就对应到两个字段上的，效率会有很大提高。
>    2. 散列索引    第二种索引叫做散列索引，就是通过散列函数来定位的一种索引，不过很少有单独使用散列索引的，反而是散列文件组织用的比较多。散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。散列索引呢就是根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多了，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高
>    3. 位图索引    位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势。位图的基本思想就是对每一个条件都用0或者1来表示，如有5条记录，性别分别是男，女，男，男，女，那么如果使用位图索引就会建立两个位图，对应男的10110和对应女的01001,这样做有什么好处呢，就是如果同时对多个这种类型的字段进行and或or查询时，可以使用按位与和按位或来直接得到结果了。
>
> B+树最常用，性能也不差，用于范围查询和单值查询都可以。特别是范围查询，非得用B+树这种顺序的才可以了。HASH的如果只是对单值查询的话速度会比B+树快一点，但是ORACLE好像不支持HASH索引，只支持HASH表空间。位图的使用情况很局限，只有很少的情况才能用，一定要确定真正适合使用这种索引才用（值的类型很少并且需要复合查询），否则建立一大堆位图就一点意义都没有了。



- 聚集索引和非聚集索引的区别（叶节点存储内容）



#### 唯一性索引和主键索引的区别

> ​    1）主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；
> ​	2）主键不允许为空值，唯一索引列允许空值；
> ​	3）一个表只能有一个主键，但是可以有多个唯一索引；
> ​	4）主键可以被其他表引用为外键，唯一索引列不可以；
> ​	5）主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别
>
> (主键更为严格)

> 1.主键约束（PRIMARY KEY）
>
> 1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。 
> 2) 是不可能（或很难）更新． 
> 3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．
> 4) 主健可作外健，唯一索引不可；
>
> 2.唯一性约束（UNIQUE）
> 1) 唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．
> 2) 只要唯一就可以更新． 
> 3) 即表中任意两行在  指定列上都不允许有相同的值，允许空（NULL）．
> 4) 一个表上可以放置多个唯一性约束
>
> 3.唯一索引（INDEX）
>
> 创建唯一索引可以确保任何生成重复键值的尝试都会失败。
>
> 唯一性约束和主键约束的区别：
>  （1）.唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。
>  （2）.在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生聚集索引，而唯一性约束产生非聚集索引
>
> 
>
> 约束和索引， 前者是用来检查数据的正确性，后者用来实现数据查询的优化，目的不同。
> 唯一性约束与唯一索引有所不同：
>
> （1）.创建唯一约束会在Oracle中创建一个Constraint，同时也会创建一个该约束对应的唯一索引。
>
> （2）.创建唯一索引只会创建一个唯一索引，不会创建Constraint。
>
> 在删除时这两者也有一定的区别：
>
> 删除唯一约束时可以只删除约束而不删除对应的索引，所以对应的列还是必须唯一的，
>
> 而删除了唯一索引的话就可以插入不唯一的值。  



#### 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）

> 1、一般来说，应该在这些列上创建索引：
>
> 在经常需要搜索的列上，可以加快搜索的速度；
>
> 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
>
> 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
>
> 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
>
> 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
>
> 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
>
> 2、 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：
>
> 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
>
> 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
>
> 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
>
> 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 



- 索引的底层实现（B+树，为何不采用红黑树，B树）

  

- B树和B+树具体实现

  

- 索引最左前缀问题

  

#### Mysql的优化（高频，索引优化，性能优化）

> https://www.cnblogs.com/zhouyusheng/p/8038224.html
>
> ① 为查询缓存优化查询
>
> ② EXPLAIN 我们的SELECT查询(可以查看执行的行数)
>
> ③ 当只要一行数据时使用LIMIT 1
>
> ④ 为搜索字段建立索引
>
> ⑤ 在Join表的时候使用相当类型的列，并将其索引
>
> ⑥ 千万不要 ORDER BY RAND  ()
>
> ⑦ 避免SELECT *
>
> ⑧ 永远为每张表设置一个ID
>
> ⑨ 可以使用ENUM 而不要VARCHAR
>
> ⑩ 尽可能的使用NOT NULL
>
> ⑪ 固定长度的表会更快
>
> ⑫ 垂直分割
>
> ⑬ 拆分打的DELETE或INSERT语句
>
> ⑭ 越小的列会越快
>
> ⑮ 选择正确的存储引擎
>
> ⑯ 小心 "永久链接"



#### 数据库引擎介绍，Innodb和Myisam的特点与区别

> **MEMORY**
>
> 使用MySQL Memory存储引擎的出发点是速度，为得到最快的响应时间，采用的逻辑存储介质是系统内存。
>
> 虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。
>
> 获得速度的同时也带来了一些缺陷。
>
> 它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。
>
> 一般在以下几种情况下使用Memory存储引擎：
>
> - 目标数据较小，而且被非常频繁地访问。 在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
> - 如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。
> - 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。
> - Memory同时支持散列索引和B树索引。
>
> **InnoDB**
>
> InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。
>
> InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：
>
> - 更新密集的表。 InnoDB存储引擎特别适合处理多重并发的更新请求。
> - 事务。 InnoDB存储引擎是支持事务的标准MySQL存储引擎。
> - 自动灾难恢复。 与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
> - 外键约束。 MySQL支持外键的存储引擎只有InnoDB。
> - 支持自动增加列AUTO_INCREMENT属性。
> - 从5.7开始innodb存储引擎成为默认的存储引擎。
>
> 一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。
>
> InnoDB改表改一行锁一行，MyISAM改一行也要锁定整个表.
>
> **MyISAM**
>
> MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。
>
> 每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。
>
> 例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：
>
> - tb_demo.frm，存储表定义。
> - tb_demo.MYD，存储数据。
> - tb_demo.MYI，存储索引。
>
> MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：
>
> \1. 选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。
>
> \2. 插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。
>
> 由此看来，MyISAM存储引擎很适合管理服务器日志数据。



#### 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）

> **一致性；**
>
> **原子性；**
>
> **隔离性；**
>
> **持久性；**

- 
- 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）
- 
- 数据库的隔离级别，Mysql和Oracle的隔离级别分别是什么
- 
- 数据库连接池的作用
- 
- Mysql的表空间方式，各自特点
- 
- 分布式事务
- 
- 数据库的范式
- 
- 数据的锁的种类，加锁的方式
- 
- 视图的作用与使用方法（如何删除等）
- 
- 项目中哪里用到了数据库，怎么用的
- 
- Memcache和Redis了解
- 

### 大数据和分布式

- Hadoop框架下，各个组件的构成及作用
- 
- BASE原则，CAP原则
- 
- 一致性算法Raft的过程
- 
- TIDB原理

> [存储](https://pingcap.com/blog-cn/tidb-internal-1/)
>
> [调度](https://pingcap.com/blog-cn/tidb-internal-3/)
>
> [计算](https://pingcap.com/blog-cn/tidb-internal-2/)

- [HBase的存储原理](https://www.cnblogs.com/panpanwelcome/p/8716652.html)
- 
- [HDFS运行原理](https://blog.csdn.net/dpengwang/article/details/79297435)
- 
- Hive的了解
- 
- Spark的了解
